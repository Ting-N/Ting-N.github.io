---
title: 《深入理解计算机系统》第二章读书笔记
published: 2025-03-09
description: 第二章 信息的表示和处理
tags: [笔记,深入理解计算机系统]
category: 《深入理解计算机系统》读书笔记
draft: false
---

# 信息的表示和处理

## 十六进制表示法

|十六进制数字|0|1|2|3|4|5|6|7|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|十进制值|0|1|2|3|4|5|6|7|
|二进制值|0000|0001|0010|0011|0100|0101|0110|0111|

|十六进制数字|8|9|A|B|C|D|E|F|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|十进制值|8|9|10|11|12|13|14|15|
|二进制值|1000|1001|1010|1011|1100|1101|1110|1111|

### 练习题2.1

**A.**

001110011010011111111000

**B.**

0xC97B

**C.**

11010101111001001100

**D.**

0x26E7B5

### 练习题2.2

|$n$|$2^n$ (十进制)|$2^n$ (十六进制)|
|:---:|:---:|:---:|
|9|512|0x200|
|19|524288|0x80000|
|14|16384|0x4000|
|16|65536|0x10000|
|17|131072|0x20000|
|5|32|0x20|
|7|128|0x80|

### 练习题2.3

|十进制|二进制|十六进制|
|:---:|:---:|:---:|
|0|0000 0000|0x00|
|167|1010 0111|0xA7|
|62|0011 1110|0x3E|
|188|1011 1100|0xBC|
|55|0011 0111|0x37|
|136|1000 1000|0x88|
|243|1111 0011|0xF3|
|82|0101 0010|0x52|
|172|1010 1011|0xAC|
|231|1110 0111|0xE7|

### 练习题2.4

**A.** 0x5044

**B.** 0x4FFC

**C.** 0x507C

**D.** 0x00AE

## 字数据大小

大多数计算机使用 8 位的块，或者 **字节** (byte), 作为最小的可寻址的内存单位。

**字长** 指明 *指针数据* 的标称大小。

**虚拟地址** 以一个字编码，对于一个字长为 $w$ 位的机器，虚拟地址的范围为 $0\sim 2^w-1$ ,程序最多访问 $2^w$ 个字节。

## 寻址和字节顺序

**小端** 最 *低* 有效字节在最前面

**大端** 最 *高* 有效字节在最前面

我们用下面的代码在 64 位 Windows 11 系统上做一个实验。

```c
#include <stdio.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len)
{
	size_t i;
	for(i = 0; i < len; i++)
	{
		printf(" %.2x",start[i]);
	}
	printf("\n");
}

void show_int(int x)
{
	show_bytes((byte_pointer) &x, sizeof(int));
}

void show_float(float x)
{
	show_bytes((byte_pointer) &x, sizeof(int));
}

void test_show_bytes(int val) { 
	int ival = val; 
	float fval = (float) ival; 
	show_int(ival); 
	show_float(fval); 
} 

int main(void)
{
	int i = 12345;
		test_show_bytes(i);
		printf("\n");
	return 0;
}
```

在上述代码中，我们试图显示 int 型和 float 型变量值为 12345 的字节表示，结果如下：

```
int   39 30 00 00
float 00 e4 40 46
```

因为 Windows 是**小端法**机器，所以最低有效字节值 **0x39** 先输出，转换为字节模式并写出二进制形式,我们发现了一个**有 13 个相匹配的位的序列**：

00003039  
0000 0000 0000 0000 001 ***1 0000 0011 1001***  
46 40 e4 00  
0100 0110 0 ***100 0000 1110 01*** 00 0000 0000

### 练习题2.5

**A.** 小端法：21 大端法：87

**B.** 小端法：21 43 大端法：87 65

**C.** 小端法：21 43 65 大端法：87 65 43

### 练习题2.6

**A.**

|十六进制|0x00359141|0x4A564504| 
|:---:|:---:|:---:|
|二进制|0000 0000 0011 0101 1001 0001 0100 0001|0100 1010 0101 0110 0100 0101 0000 0100|  

**B.**

0000 0000 001 ***1 0101 1001 0001 0100 0001***

0100 1010 0 ***101 0110 0100 0101 0000 01*** 00

有 21 位相等。

**C.** 我们发现除了最高有效位 1，整数的所有位都嵌在浮点数中。这正好也是书中示例的情况。另外，浮点数有一些非零的高位不与整数中的高位相匹配。

## 表示字符串

C 语言中字符串被编码位一个以 null （其值为 0）字符结尾的字符数组。

### 练习题2.7

61 62 63 64 65 66

## 布尔代数

**位向量** 是固定长度位 $w$、由 0 和 1 组成的串。

### 练习题2.8

|运算|结果|
|:---:|:---:|
|a|[01101001]|
|b|[01010101]|
|~a|[10010110]|
|~b|[10101010]|
|a&b|[01000001]|
|a\|b|[01111101]|
|a^b|[00111100]|

## 表示有限集合

可以用位向量 $[a_{w-1},\cdots,a_1,a_0]$ 编码任何子集 $A\subseteq {0,1,\cdots,w-1}$,其中 $a_i=1$ 当且仅当 $i\in A$。此时，$\mid$ 对应并集，$\&$ 对应交集，$~$ 对应补集。例如，位向量 $a=[01101001]$ 表示集合 $A={0,3,5,6}$。

### 练习题2.9

**A.**

|颜色|颜色的补|
|:---:|:---:|
|黑色|白色|
|蓝色|黄色|
|绿色|红紫色|
|蓝绿色|红色|

**B.**

蓝绿色 绿色 蓝色

## C语言中的位级运算

### 练习题2.10

```c
void inplace_swap(int *x, int *y) { 
	*y = *x ^ *y; /* Step 1 */
	*x = *x ^ *y; /* Step 2 */
	*y = *x ^ *y; /* Step 3 */ 
}
```

|步骤|*x|*y|
|:---:|:---:|:---:|
|初始|a|b|
|第一步|a|a^b|
|第二步|a^(a^b)=(a^a)^b=b|a^b|
|第三步|b|b^(a^b)=(b^b)^a=a|

### 练习题2.11

**A.** first = last = k

**B.** 因为此时 `*x` 和 `*y` 的值相等，而 **a ^ a = 0**。

**C.** 将 for 循环中 `first <= last` 改为 `first < last` 即可。

### 练习题2.12

**A.** `x & 0xFF`
**B.** `x ^ ~0xFF`
**C.** `x | 0xFF`

### 练习题2.13

`bis(x, y)` 等价于 `x | y`，`bic(x, y)` 等价于 `x & ~y`。

异或（排斥或）表示为 `((x & ~y) | (y & ~x))`,由以上两个函数可以表示为 `bis(bic(x, y), bic(y, x))`。

>这道题很有意思啊。把《离散数学》上学到的东西用上了。

## C语言中的逻辑运算

### 练习题2.14

0x20 0x7F 0xDF 0x00 0x01 0x01 0x00 0x01

### 练习题2.15

`!(x ^ y)`

## C语言中的移位运算

**逻辑右移** 左端补 $k$ 个 0，适用 *无符号数*。

**算术右移** 左端补 $k$ 个 *最高有效位*，适用 *有符号数*。

### 练习题2.16

|x|x|x<<3|x<<3|x>>2(逻辑的)|x>>2(逻辑的)|x>>2(算术的)|x>>2(算术的)|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|十六进制|二进制|二进制|十六进制|二进制|十六进制|二进制|十六进制|
|0xC3|1100 0011|0001 1000|0x18|0011 0000|0x30|1111 0000|0xF0|
|0x75|0111 0101|1010 1000|0xA8|0001 1101|0x1D|0001 1101|0x1D|
|0x87|1000 0111|0011 1000|0x38|0010 0001|0x21|1110 0001|0xE1|
0x66|0110 0110|0011 0000|0x30|0001 1001|0x19|0001 1001|0x19|

## 补码编码

**补码编码的定义**

对向量 $\vec{x}=[x_{w-1},x_{w-2},\cdots,x_{0}]$：

$$
B2T_{w}(\vec{x})\doteq -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_{i}2{i}
$$

>最高有效位为符号位，“权重”为 $-2^{w-1}$。

### 练习题2.17

|0x0|[0000]|0|0|
|:---:|:---:|:---:|:---:|
|0x5|[0101]|5|5|
|0x8|[1000]|8|-8|
|0xD|[1101]|13|-3|
|0xF|[1111]|15|-1|

### 练习题2.18

>没太看明白这个题是什么意思……

## 有符号数和无符号数之间的转换

**补码转无符号数**

$$
B2U_{w}(T2B_{w}(x))=T2U_{w}(x)=x+x_{w-1}2^{w}
$$

>对于大多数 C 语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

### 练习题2.19

|-8|[1000]|8|
|:---:|:---:|:---:|
|-3|[1101]|13|
|-2|[1110]|14|
|-1|[1111]|15|
|0|[0000]|0|
|5|[0101]|5|

### 练习题2.20

补码转无符号时，最高位由*标志功能*转为*计数功能*，两者相差 $2\cdot 2^{w-1}=2^{w}$，其他位功能不变。

### 练习题2.21

|类型|求值|
|:---:|:---:|
|无符号数|1|
|有符号数|1|
|无符号数|0|
|有符号数|1|
|无符号数|1|

>$TMin_{32}=-2147483647-1$

## 扩展一个数字的位表示

**零扩展** *无符号数*开头加 0。

**补码的符号扩展** 根据最高有效位加 0 或 1。

### 练习题2.23

**A.**

|w|fun1(w)|fun2(w)|
|:---:|:---:|:---:|
|0x00000076|0x00000076|0x00000076|
|0x87654321|0x00000021|0x00000021|
|0x000000C9|0x000000C9|0xFFFFFFC9|
|0xEDCBA987|0x00000087|0xFFFFFF87|

**B.** fun1从参数低 8 位取值，范围 0 ~ 255。fun2也从参数低 8 位取值，但进行符号扩展，范围 -128 ~ 127。

## 截断数字

取低 $k$ 位，补码截断最*高*位转换为*符号位*。

### 练习题2.24

无符号截断值|补码截断值|
|:---:|:---:|
|0|0|
|2|2|
|1|1|
|3|3|
|7|-1|



